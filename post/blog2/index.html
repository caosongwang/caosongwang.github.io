<!doctype html>
<html lang="en-us">
  <head>
    <title>C&#43;&#43;笔记：const与static // 学习使我快乐</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.55.6" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="John Doe" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="/caosongwang.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C&#43;&#43;笔记：const与static"/>
<meta name="twitter:description" content="一、static
1.在函数体一个被声明为静态的变量在这一函数被调用的过程中维持其值不变；
2.在模块内，一个被声明为变量可以被模块内所用，函数访问，但不能被模块外其他函数访问，它是一个本地全局变量；
3.在模块外，一个被声明为静态的函数只可被这一模块内的其他函数调用，那就是这个函数被限制在声明它的模块的本地范围内使用。
4.C&#43;&#43;中的类成员声明static
(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。 (2)不能将静态成员函数定义为虚函数。 (3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。
(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C&#43;&#43;和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过） (5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。 (6)静态数据成员在&lt;定义或说明&gt;时前面加关键字static。 (7)静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误） (8)静态成员初始化与一般数据成员初始化不同:
初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；
初始化时不加该成员的访问权限控制符private，public等； 初始化时使用作用域运算符来标明它所属类；
所以我们得出静态数据成员初始化的格式：
&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;
(9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。
二、const
 const 在C和C&#43;&#43;中的区别  C&#43;&#43;中的const正常情况下是看成编译期的常量,编译器并不为const分配空间,只是在编译的时候将期值保存在名字表中,并在适当的时候折合在代码中. 所以在C&#43;&#43;中const修饰的量可以用在数组的定义中。
而在C中,const是一个不能被改变的普通变量,既然是变量,就要占用存储空间,所以编译器不知道编译时的值.而且,数组定义时的下标必须为常量.
在C语言中: const int size; 这个语句是正确的，因为它被C编译器看作一个声明,指明在别的地方分配存储空间.
但在C&#43;&#43;中这样写是不正确的.
C&#43;&#43;中const默认是内部连接,如果想在C&#43;&#43;中达到以上的效果,必须要用extern关键字. C&#43;&#43;中,const默认使用内部连接.而C中使用外部连接.
内连接:编译器只对正被编译的文件创建存储空间,别的文件可以使用相同的表示符或全局变量.C/C&#43;&#43;中内连接使用static关键字指定.
外连接:所有被编译过的文件创建一片单独存储空间.一旦空间被创建,连接器必须解决对这片存储空间的引用.全局变量和函数使用外部连接.通过extern关键字声明,可以从其他文件访问相应的变量和函数. C&#43;&#43;中,是否为const分配空间要看具体情况. 如果加上关键字extern或者取const变量地址,则编译器就要为const分配存储空间.
C&#43;&#43;中定义常量的时候不再采用define,因为define只做简单的宏替换，并不提供类型检查.
2.const指针和指向const的指针
在C语言中const指针表示该指针是一个常量，一旦进行初始化完成之后就无法改变它指向的位置。指向const的指针说明使用这个指针无法改变其指向的地址处的值，特别强调的一点是使用这个指针不能够改变。言外之意就是说，可以通过其他的方式改变。
比如：char ch=&lsquo;c&rsquo;;
const char *ptr=&ch;
*ptr=&lsquo;a&rsquo;;//这样做是不允许的
ch=&lsquo;a&rsquo;;//这样做完全可以，并且*ptr的值也是&rsquo;a&rsquo;
const用法小结：
const最常用的就是定义常量，除此之外，它还可以修饰函数的参数、返回值和函数的定义体。
 const修饰函数的参数 如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const 修饰，否则该参数将失去输出功能。 const 只能修饰输入参数： 如果输入参数采用“指针传递”，那么加const 修饰可以防止意外地改动该指针，起到保护作用。 将“const &amp;”修饰输入参数的用法总结如下：  (1)对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void Func(A a) 改为void Func(const A &amp;a)。"/>

    <meta property="og:title" content="C&#43;&#43;笔记：const与static" />
<meta property="og:description" content="一、static
1.在函数体一个被声明为静态的变量在这一函数被调用的过程中维持其值不变；
2.在模块内，一个被声明为变量可以被模块内所用，函数访问，但不能被模块外其他函数访问，它是一个本地全局变量；
3.在模块外，一个被声明为静态的函数只可被这一模块内的其他函数调用，那就是这个函数被限制在声明它的模块的本地范围内使用。
4.C&#43;&#43;中的类成员声明static
(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。 (2)不能将静态成员函数定义为虚函数。 (3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。
(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C&#43;&#43;和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过） (5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。 (6)静态数据成员在&lt;定义或说明&gt;时前面加关键字static。 (7)静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误） (8)静态成员初始化与一般数据成员初始化不同:
初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；
初始化时不加该成员的访问权限控制符private，public等； 初始化时使用作用域运算符来标明它所属类；
所以我们得出静态数据成员初始化的格式：
&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;
(9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。
二、const
 const 在C和C&#43;&#43;中的区别  C&#43;&#43;中的const正常情况下是看成编译期的常量,编译器并不为const分配空间,只是在编译的时候将期值保存在名字表中,并在适当的时候折合在代码中. 所以在C&#43;&#43;中const修饰的量可以用在数组的定义中。
而在C中,const是一个不能被改变的普通变量,既然是变量,就要占用存储空间,所以编译器不知道编译时的值.而且,数组定义时的下标必须为常量.
在C语言中: const int size; 这个语句是正确的，因为它被C编译器看作一个声明,指明在别的地方分配存储空间.
但在C&#43;&#43;中这样写是不正确的.
C&#43;&#43;中const默认是内部连接,如果想在C&#43;&#43;中达到以上的效果,必须要用extern关键字. C&#43;&#43;中,const默认使用内部连接.而C中使用外部连接.
内连接:编译器只对正被编译的文件创建存储空间,别的文件可以使用相同的表示符或全局变量.C/C&#43;&#43;中内连接使用static关键字指定.
外连接:所有被编译过的文件创建一片单独存储空间.一旦空间被创建,连接器必须解决对这片存储空间的引用.全局变量和函数使用外部连接.通过extern关键字声明,可以从其他文件访问相应的变量和函数. C&#43;&#43;中,是否为const分配空间要看具体情况. 如果加上关键字extern或者取const变量地址,则编译器就要为const分配存储空间.
C&#43;&#43;中定义常量的时候不再采用define,因为define只做简单的宏替换，并不提供类型检查.
2.const指针和指向const的指针
在C语言中const指针表示该指针是一个常量，一旦进行初始化完成之后就无法改变它指向的位置。指向const的指针说明使用这个指针无法改变其指向的地址处的值，特别强调的一点是使用这个指针不能够改变。言外之意就是说，可以通过其他的方式改变。
比如：char ch=&lsquo;c&rsquo;;
const char *ptr=&ch;
*ptr=&lsquo;a&rsquo;;//这样做是不允许的
ch=&lsquo;a&rsquo;;//这样做完全可以，并且*ptr的值也是&rsquo;a&rsquo;
const用法小结：
const最常用的就是定义常量，除此之外，它还可以修饰函数的参数、返回值和函数的定义体。
 const修饰函数的参数 如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const 修饰，否则该参数将失去输出功能。 const 只能修饰输入参数： 如果输入参数采用“指针传递”，那么加const 修饰可以防止意外地改动该指针，起到保护作用。 将“const &amp;”修饰输入参数的用法总结如下：  (1)对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void Func(A a) 改为void Func(const A &amp;a)。" />
<meta property="og:type" content="article" />
<meta property="og:url" content="caosongwang.github.io/post/blog2/" />
<meta property="article:published_time" content="2019-08-03T09:09:10&#43;08:00"/>
<meta property="article:modified_time" content="2019-08-03T09:09:10&#43;08:00"/>


  </head>
  <body>
    <header class="app-header">
      <a href="caosongwang.github.io"><img class="app-header-avatar" src="/caosongwang.github.io/avatar.jpg" alt="John Doe" /></a>
      <h1>学习使我快乐</h1>
      <p>路在脚下，心向远方</p>
      <div class="app-header-social">
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">C&#43;&#43;笔记：const与static</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Aug 3, 2019
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          1 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>一、static</p>

<p>1.在函数体一个被声明为静态的变量在这一函数被调用的过程中维持其值不变；</p>

<p>2.在模块内，一个被声明为变量可以被模块内所用，函数访问，但不能被模块外其他函数访问，它是一个本地全局变量；</p>

<p>3.在模块外，一个被声明为静态的函数只可被这一模块内的其他函数调用，那就是这个函数被限制在声明它的模块的本地范围内使用。</p>

<p>4.C++中的类成员声明static</p>

<p>(1)类的静态成员函数是属于整个类而非类的对象，所以它没有this指针，这就导致 了它仅能访问类的静态数据和静态成员函数。      </p>

<p>(2)不能将静态成员函数定义为虚函数。      </p>

<p>(3)由于静态成员声明于类中，操作于其外，所以对其取地址操作，就多少有些特殊 ，变量地址是指向其数据类型的指针 ，函数地址类型是一个“nonmember函数指针”。</p>

<p>(4)由于静态成员函数没有this指针，所以就差不多等同于nonmember函数，结果就 产生了一个意想不到的好处：成为一个callback函数，使得我们得以将C++和C-based X W indow系统结合，同时也成功的应用于线程函数身上。 （这条没遇见过）  </p>

<p>(5)static并没有增加程序的时空开销，相反她还缩短了子类对父类静态成员的访问 时间，节省了子类的内存空间。      </p>

<p>(6)静态数据成员在&lt;定义或说明&gt;时前面加关键字static。      </p>

<p>(7)静态数据成员是静态存储的，所以必须对它进行初始化。 （程序员手动初始化，否则编译时一般不会报错，但是在Link时会报错误）     </p>

<p>(8)静态成员初始化与一般数据成员初始化不同:</p>

<p>初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；</p>

<p>初始化时不加该成员的访问权限控制符private，public等；        </p>

<p>初始化时使用作用域运算符来标明它所属类；</p>

<p>所以我们得出静态数据成员初始化的格式：</p>

<p>&lt;数据类型&gt;&lt;类名&gt;::&lt;静态数据成员名&gt;=&lt;值&gt;</p>

<p>(9)为了防止父类的影响，可以在子类定义一个与父类相同的静态变量，以屏蔽父类的影响。这里有一点需要注意：我们说静态成员为父类和子类共享，但我们有重复定义了静态成员，这会不会引起错误呢？不会，我们的编译器采用了一种绝妙的手法：name-mangling 用以生成唯一的标志。</p>

<p>二、const</p>

<ol>
<li>const 在C和C++中的区别</li>
</ol>

<p>C++中的const正常情况下是看成编译期的常量,编译器并不为const分配空间,只是在编译的时候将期值保存在名字表中,并在适当的时候折合在代码中. 所以在C++中const修饰的量可以用在数组的定义中。</p>

<p>而在C中,const是一个不能被改变的普通变量,既然是变量,就要占用存储空间,所以编译器不知道编译时的值.而且,数组定义时的下标必须为常量.</p>

<p>在C语言中: const int size; 这个语句是正确的，因为它被C编译器看作一个声明,指明在别的地方分配存储空间.</p>

<p>但在C++中这样写是不正确的.</p>

<p>C++中const默认是内部连接,如果想在C++中达到以上的效果,必须要用extern关键字. C++中,const默认使用内部连接.而C中使用外部连接.</p>

<p>内连接:编译器只对正被编译的文件创建存储空间,别的文件可以使用相同的表示符或全局变量.C/C++中内连接使用static关键字指定.</p>

<p>外连接:所有被编译过的文件创建一片单独存储空间.一旦空间被创建,连接器必须解决对这片存储空间的引用.全局变量和函数使用外部连接.通过extern关键字声明,可以从其他文件访问相应的变量和函数. C++中,是否为const分配空间要看具体情况. 如果加上关键字extern或者取const变量地址,则编译器就要为const分配存储空间.</p>

<p>C++中定义常量的时候不再采用define,因为define只做简单的宏替换，并不提供类型检查.</p>

<p>2.const指针和指向const的指针</p>

<p>在C语言中const指针表示该指针是一个常量，一旦进行初始化完成之后就无法改变它指向的位置。指向const的指针说明使用这个指针无法改变其指向的地址处的值，特别强调的一点是使用这个指针不能够改变。言外之意就是说，可以通过其他的方式改变。</p>

<p>比如：char ch=&lsquo;c&rsquo;;</p>

<p>const char *ptr=&ch;</p>

<p>*ptr=&lsquo;a&rsquo;;//这样做是不允许的</p>

<p>ch=&lsquo;a&rsquo;;//这样做完全可以，并且*ptr的值也是&rsquo;a&rsquo;</p>

<p>const用法小结：</p>

<p>const最常用的就是定义常量，除此之外，它还可以修饰函数的参数、返回值和函数的定义体。</p>

<ol>
<li>const修饰函数的参数
如果参数作输出用，不论它是什么数据类型，也不论它采用“指针传递”还是“引用传递”，都不能加const 修饰，否则该参数将失去输出功能。
const 只能修饰输入参数：
如果输入参数采用“指针传递”，那么加const 修饰可以防止意外地改动该指针，起到保护作用。
将“const &amp;”修饰输入参数的用法总结如下：</li>
</ol>

<p>(1)对于非内部数据类型的输入参数，应该将“值传递”的方式改为“const 引用传递”，目的是提高效率。例如将void Func(A a) 改为void Func(const A &amp;a)。</p>

<p>(2)对于内部数据类型的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如void Func(int x) 不应该改为void Func(const int &amp;x)。</p>

<ol>
<li>const 修饰函数的返回值
如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。例如函数
const char * GetString(void);
如下语句将出现编译错误：
char *str = GetString();
正确的用法是
const char *str = GetString();</li>
</ol>

<p>如果返回值不是内部数据类型，将函数A GetA(void) 改写为const A &amp; GetA(void)的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。
函数返回值采用“引用传递”的场合并不多，这种方式一般只出现在类的赋值函数中，目的是为了实现链式表达。
例如：</p>

<p>class A
{
A &amp; operate = (const A &amp;other); // 赋值函数
};
A a, b, c; // a, b, c 为A 的对象</p>

<p>a = b = c; // 正常的链式赋值</p>

<p>(a = b) = c; // 不正常的链式赋值，但合法</p>

<p>如果将赋值函数的返回值加const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。</p>

<ol>
<li>const修饰成员函数
关于Const函数的几点规则：
1). const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.</li>
</ol>

<p>2). const对象的成员是不可修改的,然而const对象通过指针维护的对象却是可以修改的.</p>

<p>3). const成员函数不可以修改对象的数据,不管对象是否具有const性质.它在编译时,以是否修改成员数据为依据,进行检查.</p>

<p>4). 然而加上mutable修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的</p>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
